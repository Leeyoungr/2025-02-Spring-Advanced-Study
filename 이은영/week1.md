# 1장. 오브젝트와 의존관계

## 𓇼 1.1 초난감 DAO

DAO(Data Access Object)
→ DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

**UserDao**

```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
        "jdbc:mysql://localhost/springbook", "spring", "book");

        PreparedStatement ps = c.prepareStatement(
                "insert into users(id, name, password) values(?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
				"jdbc:mysql://localhost/springbook", "spring", "book");
        PreparedStatement ps = c
                .prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

## 𓇼 1.2 DAO 분리

### **🥶 현재 UserDao의 관심사항 ( 너무 많다 !! 😖 )**

- DB와 연결을 위한 커넥션을 어떻게 가져올지.
- 사용자 등록을 위해 DB에 보낼 SQL문장을 담을 Statement를 만들고 실행하기.
- 작업이 끝나면 사용한 리소스를 닫아 시스템에 반환하기.

1. **관심사의 분리** : 관심이 같은 것 끼리는 하나의 객체안으로 또는, 친한 객체로 모이게 하고 관심이 다른것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.
   → **분리**와 **확장**을 고려한 설계를 해야지 변경이 일어날 때 필요한 작업을 최소화하고, 변경으로 인해 다른 곳에 문제가 일어나지 않다
2. **커넥션 만들기의 추출**
   - 중복 코드의 메소드 추출
     - getConnection() 독립적인 메소드로 커넥션을 가져오는 중복된 코드를 분리
3. **DB 커넥션 만들기의 독립**

   **요구사항** : 납품 과정에서 UserDao를 공개하지 않고, 고객 스스로 원하는 DB 커넥션 생성 방식을 적용하면서 UserDao를 사용하게 할 수 있게 하기

   - **상속을 통해 확장**
     → UserDao에서 getConnection 메소드를 추상메소드로 만들어서 고객사에서 서브클래스를 구현하여 사용하도록 한다.
   - **상속의 문제점**
     → 이미 UserDao가 다른 목적을 위해 상속을 하고 있다면 ? (다중상속 문제)
     → 상속을 통한 상하위 클래스의 관계는 밀접하다 (여전히 두 가지 다른 관심사에 대해 긴밀한 결합 허용-

   **🪻** **템플릿 메소드 패턴 🪻**

   - 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
   - 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록
     하는 방법

## 𓇼 1.3 DAO의 확장

변화의 성격이 다른것을 분리해서, 서로 영향을 주지 않은채로 각각 필요한 시점에서 독립적으로 변경할 수 있기 위해 추상 클래스를 만들고, 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만들었다.
그러나, 상속이라는 방법을 사용했기에 여러가지 단점이 많다.

→ 클래스 분리나 인터페이스를 도입하더라도 또 다시 원점으로 돌아간다 . .

**🌟  그렇다면, 관계설정 책임을 분리하자 🌟**

클라이언트 오브젝트에 제 3의 관심사항인 UserDao와 ConnectionMaker 구현클래스의 관계를 결정해주는 기능을 둔다

**원칙과 패턴**

- 개방-폐쇄 원칙 : 클래스와 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 높은 응집도와 낮은 결합도
  - 높은 응집도:
    - 하나의 모듈이나 클래스가 하나의 책임 또는 관심사에 집중해야 한다.
    - 공통 관심사는 하나의 클래스에 모아야 한다.
  - 낮은 결합도:
    - 서로 다른 책임과 관심사를 가진 객체 또는 모듈 간의 연결은 느슨하게 유지해야 한다.
    - 느슨한 결합: 관계를 유지하는 데 꼭 필요한 최소한의 방법만 제공하고, 나머지는 서로 독립적이어야 한다.

## 𓇼 1.4 제어의 역전(IoC)

- **팩토리**
  → 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 담당하는 오브젝트
- **제어권의 이전을 통한 제어관계 역전**
  > UserDao가 자신이 사용할 ConnectionMaker의 구현클래스를 자신이 결정하고, 그 오브젝트를
  > 필요한 시점에서 생성해두고 각 메소드에서 사용한다. 모든 오브젝트가 능동적으로 자신이 사용할
  > 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다.
  > 즉, 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조
  **제어의 역전**이란 이런 제어 흐름의 개념을 꺼꾸로 뒤집는 것
  제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택 및 생성하지 않는다
  >

## 𓇼 1.5 스프링의 IoC

**오브젝트 팩토리와 비교하여, 애플리케이션 컨텍스트를 사용하면 얻을 수 있는 장점**

1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
3. 빈을 검색하는 다양한 방법을 제공한다.

**스프링 IoC의 용어 정리**

> **Bean**
>
> 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트
> 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다.

> **Bean factory**
>
> 스프링의 IoC를 담당하는 핵심 컨테이너
> 빈을 등록, 생성, 조회, 반환 등과 같이 빈을 관리하는 기능을 담당한다.

> **Application context**
>
> 빈 팩토리를 확장한 IoC 컨테이너
> 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하며, 스프링이 제공하는 각종 부가 서비스를 추가적으로 제공한다.
> ApplicationContext는 BeanFactory를 상속한다.

> **설정정보/설정 메타정보**
>
> 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보

> **컨테이너 또는 IoC 컨테이너**
>
> IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 한다.
> 애플리케이션 컨텍스트보다 좀 더 추상적인 표현이다.

## 𓇼 1.6 싱글톤 레지스트리와 오브젝트 스코프

**🤔 왜 스프링은 싱글톤으로 빈을 만드는 것일까?**

스프링은 주로 서버 환경을 다루기 때문에, 클라이언트 요청마다 객체를 새로 만드는 것은 서버에 부하를 준다.따라서, 서블릿을 이용해 클래스당 하나의 객체를 만들어 여러 요청에 대해 공유해 사용 !

**싱글톤 패턴의 한계**

- **상속 불가 :** private 생성자를 갖고 있기 때문이다.
- **테스트하기 어려움** : mock 객체로 대체하기 어렵다.
- **서버 환경의 불안정성 :** 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- **전역 상태 문제 :** 싱글톤의 사용은 전역 상태를 만들어 자유롭게 접근할 수 있기때문에 바람직하지 못하다.

→ **스프링은 IoC 컨테이너이자 싱글톤 레지스트리로써, 효율적인 객체 관리를 지원**

**스프링 빈의 스코프 :** 빈이 생성되고, 존재하고, 적용되는 범위

## 𓇼 1.7 의존관계 주입(DI)

- **의존관계 주입 :** 구체적인 오브젝트와 클라이언트를 런타임 시에 연결해주는 작업
- **의존관계 주입의 핵심**
  - 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것
  - 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다
- **의존관계 검색**(Dependency Lookup)
  - 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용
  - 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
  - 스프링 빈이 아닌 오브젝트에서 스프링 빈을 가져와야 할 때 의존관계 검색이 유용하다.
- **메소드를 이용한 의존관계 주입**
  - 수정자 메소드(Setter)
  - 일반 메소드

## 𓇼 1.8 XML을 이용한 설정

스프링은 DaoFactory와 같은 자바 클래스를 이용하는 것 외에도, 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다. 가장 **대표적인 것이 바로 XML**이다.

**XML 의 장점**

- 단순한 텍스트 파일이라 다루기 쉽다.
- 환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다.
- 스키마나 DTD를 이용해 정해진 포맷을 따라 작성됐는지 손쉽게 확인할 수 있다.

**XML 설정**

|             | 자바 코드 설정정보        | XML 설정정보               |
| ----------- | ------------------------- | -------------------------- |
| 빈 설정파일 | `@Configuration`          | `<beans>`                  |
| 빈의 이름   | `@Bean methodName()`      | `<bean id="methodName"`    |
| 빈의 클래스 | `return new BeanClass();` | `class="a.b.c.BeanClass">` |
